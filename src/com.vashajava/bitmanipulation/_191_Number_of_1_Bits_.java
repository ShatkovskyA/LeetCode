package com.vashajava.bitmanipulation;

/**
 * Класс _191_Number_of_1_Bits_ - число их 1-го бита.
 *
 * @author Anton Shatkovskiy
 * @created 10.07.2024 г.
 */

/*
Write a function that takes the binary representation of a positive integer and returns the number of
set bits it has (also known as the Hamming weight).

Example 1:

Input: n = 11
Output: 3
Explanation:

The input binary string 1011 has a total of three set bits.

Example 2:
Input: n = 128
Output: 1

Explanation:

The input binary string 10000000 has a total of one set bit.

Example 3:
Input: n = 2147483645
Output: 30

Explanation:
The input binary string 1111111111111111111111111111101 has a total of thirty set bits.

Constraints:
1 <= n <= 231 - 1

Follow up: If this function is called many times, how would you optimize it?

ПЕРЕВОД: 191. Число их 1-го бита.
Напишите функцию, которая принимает двоичное представление целого положительного числа и возвращает количество
установленных битов, которое у нее есть (также известное как вес Хэмминга).

Т. е. если число 5 в двоичном представлении равно как 101, то, кол-во бит 1 будет равно 2, вот это количество 1 и надо подсчитать.

Пример 1:

Входные данные: n = 11
Выходные данные: 3
Объяснение:

Входная двоичная строка 1011 содержит в общей сложности три заданных бита.

Пример 2:
Входные данные: n = 128
Выходные данные: 1

Объяснение:

Входная двоичная строка 10000000 содержит всего один установленный бит.

Пример 3:
Ввод: n = 2147483645
Вывод: 30

Объяснение:
Входная двоичная строка 1111111111111111111111111111101 содержит в общей сложности тридцать установленных битов.

Ограничения:
1 <= n <= 231 - 1

Продолжение: Если эта функция вызывается много раз, как бы вы ее оптимизировали?
 */
public class _191_Number_of_1_Bits_ {

  public static void main(String[] args) {

    int n = 11;

    Solution191 solution191 = new Solution191();
    int hammingWeight = solution191.hammingWeight(n);
    System.out.println(hammingWeight);

  }

  static class Solution191 {
    /**
     * Этот метод вычисляет количество 1-битов в двоичном представлении числа.
     * Обрабатывает входное число как значение без знака.
     *
     * @param n - Входное целое число (рассматриваемое как беззнаковое), в котором учитываются 1-биты.
     * @return число единиц в двоичном представлении n.
     */
    public int hammingWeight(int n) {
      // вводим и инициализируем интовую переменную счетчика для сохранения количества встреченных 1-битных символов
     int onesCount = 0;
     // далее используем цикл while с условием
      // пока '!=0' в условии, чтобы убедиться, что мы обрабатываем все биты n
      //  и, поскольку Java изначально не поддерживает unsigned int, мы интерпретируем n как unsigned, сравнивая его непосредственно с 0
      while (n != 0) {
        // тут реализуем формулу  n &= (n - 1)
        // т. е. применяем прием манипулирования битами n & (n - 1), который удаляет наименее значимый 1-бит в n
        n &= n - 1;
        // и далее увеличиваем счетчик - количество битов на 1 для каждого бита, очищенного с помощью описанной выше операции
        ++onesCount;
      }
      // ну и возвращаем этот счетчик как общее количество найденных 1-битных символов
      return onesCount;
    }
  }
}

/*
Временная сложность алгоритма равна O(k), где k– количество 1-битов в n.
В худшем случае, когда nстепень двойки kбудет логарифмической по значению, nпоскольку будет только один 1-бит.
В среднем случае оно будет меньше логарифмического, поскольку числа обычно имеют количество единиц, меньшее максимально возможного.
Следовательно, с точки зрения nвременную сложность можно рассматривать,
O(log n)поскольку kона не превышает количества битов в n, которое является логарифмом n.
 */
