package com.vashajava.array;

import java.util.ArrayList;
import java.util.List;

/**
 * _78_Subsets_.
 *
 * @author Anton Shatkovskiy
 * @created 07.11.2024 г.
 */

/*
Given an integer array nums of unique elements, return all possible
subsets (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

Example 1:
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

Example 2:
Input: nums = [0]
Output: [[],[0]]

Constraints:

1 <= nums.length <= 10
-10 <= nums[i] <= 10
All the numbers of nums are unique.

ПЕРЕВОД: 78. Подмножества.
Учитывая целочисленный массив nums уникальных элементов, верните все возможные
подмножества (набор степеней).

Набор решений не должен содержать повторяющихся подмножеств. Верните решение в любом порядке.

Пример 1:
Ввод: nums = [1,2,3]
Вывод: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

Пример 2:
Ввод: nums = [0]
Вывод: [[],[0]]

Ограничения:

1 <= nums.длина <= 10
-10 <= nums[i] <= 10
Все номера имен уникальны.
 */
public class _78_Subsets_ {

  public static void main(String[] args) {

    int[] nums = {1, 2, 3};

    Solution78 solution78 = new Solution78();
    List<List<Integer>> subsets = solution78.subsets(nums);
    System.out.println(subsets);

  }

  // используем концепцию, известную как поиск в глубину (DFS)
  static class Solution78 {
    // ТРАДИЦИОННО СОЗДАЕМ И ИНИЦИАЛИЩИРУЕМ НЕОБХОДИМЫЕ ПЕРЕМЕННЫЕ В РАМКАХ КЛАССА - т. е. приватные
    // создаем и инициализируем список для хранения всех подмножеств
    private List<List<Integer>> subsetList = new ArrayList<>();

    // создаем и инициализируем временный список для хранения одного подмножества
    private List<Integer> timeSubset = new ArrayList<>();

    // ну и последнее создаем и инициализируем массив для хранения заданных чисел
    private int[] numbers;

    /**
     * Это основной метод, который возвращает все возможные подмножества данного массива.
     * @param - массив целых чисел, для которых необходимо найти подмножества.
     * @return - список всех возможных подмножеств данного массива.
     */
    public List<List<Integer>> subsets(int[] nums) {
      // тут присваиваем массиву для хранения аргумент массива из метода
      this.numbers = nums;
      // ничинаем поиск в глубину (DFS) с первого индекса вызовом рекурсивной функции
      depthFirstSearch(0);
      return subsetList;
    }

    /**
     * Это собственно говоря рекурсивный метод, кот. использует поиск в глубину (DFS) для изучения всех потенциальных подмножеств.
     * @param index - Текущий индекс в исследуемом массиве numbers.
     */
    private void depthFirstSearch(int index) {
      // задаем условия, итак, если текущий индекс достиг длины массива,
      // это означает, что мы сформировали подмножество (имеется ввиду временное подмножество),
      // которое теперь можно добавить в список подмножеств (основной, возвращаемый)
      if(index == numbers.length) {
        subsetList.add(new ArrayList<>(timeSubset));
        return;
      }

      // ТЕПЕРЬ РАССМОТРИМ ВСЕ СЛУЧАИ
      // Случай 1: Текущий номер исключен из подмножества,
      // поэтому просто вызываем dfs для следующего индекса
      depthFirstSearch(index + 1);

      // Случай 2: Текущий номер включен в подмножество
      // добавляем текущий номер в timeSubset
      timeSubset.add(numbers[index]);

      // переходим к следующему индексу для дальнейшего изучения с учетом текущего номера - т. е. опять вызываем рекурсивную функцию
      depthFirstSearch(index + 1);

      // Возвращаемся назад: удаляем последний номер, добавленный во временное подмножество,
      // и это фактически удаляет текущий номер из подмножества
      timeSubset.remove(timeSubset.size() - 1);
    }
  }
}
/*
У каждого числа есть две возможности: либо оно является частью подмножества, либо нет.
Таким образом, для каждого элемента во входном списке nums мы выполняем два рекурсивных вызова.
В результате получается бинарное дерево решений с общим количеством 2^n конечных узлов (где n - количество элементов в nums).

Это приводит к общему количеству 2^n вызовов функций.
В каждом вызове мы имеем дело с O(1) операциями сложности (исключая рекурсивные вызовы),
такими как добавление элемента во временный список t или добавление списка к ans.

Следовательно, временная сложность кода составляет O(2^n).
 */
