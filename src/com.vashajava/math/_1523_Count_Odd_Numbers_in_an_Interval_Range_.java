package math;

/**
 * _1523_Count_Odd_Numbers_in_an_Interval_Range_.
 *
 * @author Anton Shatkovskiy
 * @created 23.05.2024 г.
 */

/*
Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive).

Example 1:

Input: low = 3, high = 7
Output: 3
Explanation: The odd numbers between 3 and 7 are [3,5,7].

Example 2:

Input: low = 8, high = 10
Output: 1
Explanation: The odd numbers between 8 and 10 are [9].

Constraints:

0 <= low <= high <= 10^9

ПЕРЕВОД: 1523. Подсчитывайте нечетные числа в диапазоне интервалов

Даны два неотрицательных целых числа low и high.
Возвращает количество нечетных чисел между low и high (включительно).

Пример 1:

Входные данные: низкое значение = 3, высокое значение = 7
Выходные данные: 3
Пояснение: Нечетными числами между 3 и 7 являются [3,5,7].

Пример 2:

Входные данные: низкое значение = 8, высокое значение = 10
Выходные данные: 1
Пояснение: Нечетными числами между 8 и 10 являются [9].

Ограничения:

0 <= низкий <= высокий <= 10^9
 */

  /*
  прямое применение арифметической операции и битового сдвига, которые являются операциями O (1) временной сложности.
  Эффективность решения является результатом формулы, которая использует присущий ей шаблон чередования нечетных и четных чисел.
   */
public class _1523_Count_Odd_Numbers_in_an_Interval_Range_ {

  public static void main(String[] args) {

    int low = 3;
    int hight = 7;

    Solution1523 solution1523 = new Solution1523();
    System.out.println(solution1523.countOdds(low, hight));


  }

  static class Solution1523 {

    // Функция для подсчета количества нечетных чисел между низким и высоким значением (включительно)
    // используются битовые сдвиги, предыстория:
    /*
       Битовый сдвиг на одну позицию вправо эквивалентен делению числа на 2,
       потому что при сдвиге вправо все биты числа сдвигаются на одну позицию вправо,
       а крайний правый бит уходит за пределы числа.
       Это означает, что в результирующем числе на один бит меньше, что эквивалентно делению числа на 2.

       Например, если у нас есть число 8 в двоичном представлении 1000,
       и мы сдвигаем его на одну позицию вправо, то получим 0100,
       что в десятичном представлении равно 4.
       Таким образом, битовый сдвиг на одну позицию вправо эквивалентен делению числа на 2.
       */
    public int countOdds(int low, int high) {

       /*
       Выражение (high + 1) >> 1 вычисляет количество нечетных чисел из диапазона 1 до high.
       Этот термин high + 1 добавляет еще одно число, чтобы облегчить правильное деление на 2 (поскольку нас интересуют нечетные числа).
       Операция битового сдвига >> 1 эффективно делит значение на 2.
       */

      /*
       Аналогично, выражение (low >> 1) вычисляет количество нечетных чисел в диапазоне от 1 до low - 1.
       Это работает, потому что low само по себе не включено, а битовый сдвиг на одну позицию вправо делится low на 2.
       Если low нечетное число, вычитание единицы перед делением дает правильное количество нечетных чисел ниже low.
       */

      /*
      Путем вычитания количества нечетных чисел ниже low из количества нечетных чисел до high включительно,
      остается количество нечетных чисел в инклюзивном диапазоне между low и high.
       */
      // ((high + 1) >> 1) вычисляет количество нечетных чисел от 1 до высокого
      // (low >> 1) вычисляет количество нечетных чисел от 1 до (низкий - 1)
      // Вычитание этих двух чисел дает количество нечетных чисел от низкого до высокого

      return ((high + 1) >> 1) - (low >> 1);

          }
  }


}
