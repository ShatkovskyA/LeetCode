package com.vashajava.dynamicprogramming;

import java.util.Arrays;

/**
 * Класс _5_Longest_Palindromic_Substring_ - самая длинная палиндромная подстрока.
 *
 * @author Anton Shatkovskiy
 * @created 14.11.2024 г.
 */

/*
Given a string s, return the longest palindromic substring in s.

Example 1:
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

Example 2:
Input: s = "cbbd"
Output: "bb"

Constraints:

1 <= s.length <= 1000
s consist of only digits and English letters.

ПЕРЕВОД: 5. Самая длинная палиндромная подстрока.
Учитывая строку s, верните самую длинную палиндромную подстроку в s. - т. е. найти самый длинный палиандром

Пример 1:
Ввод: s = "babad"
Вывод: "bab"
Пояснение: "aba" также является допустимым ответом.

Пример 2:
Ввод: s = "cbbd"
Вывод: "bb"

Ограничения:

1 <= сек.длина <= 1000
сек. состоит только из цифр и английских букв.
 */
public class _5_Longest_Palindromic_Substring_ {

  public static void main(String[] args) {

    String s = "babad";

    Solution5 solution5 = new Solution5();
    String longestPalindrome = solution5.longestPalindrome(s);
    System.out.println(longestPalindrome);

  }

  static class Solution5 {
    public String longestPalindrome(String s) {
      // возвращаем длину строки
      int n = s.length();
      // далее создаем таблицу динамического программирования (DP) - эта таблица в виде матрицы
      boolean[][] dp = new boolean[n][n];

      // инициализируем все подстроки длиной 1 (один символ) как палиндром - т. к. люая буква, симовл - это палиандр
      // т. е. пробегаемся циклом без индексов и заполняем методм массив значениями
      for(boolean[] row : dp) {
        // fill() - заполняет переданный массив переданным значением, "заводской" библиотечный метод класса Arrays
        Arrays.fill(row, true);
      }

      // задаем начальный индекс самой длинной найденной палиндромной подстроки
      int startIdx = 0;
      // тут задаем длину самой длинной найденной палиндромной подстроки, которую иницициализируем значением длины 1
      int maxLentgh = 1;

      // теперь создаем таблицу DP по принципу "снизу вверх" - циклом обычным - поэтому и так задаем условие, "нестандартно"
      // начинаем с предпоследнего символа и двигайтесь в обратном направлении
      for(int i = n - 1; i >= 0; --i) {
        // сравниваем его с символами, стоящими перед ним
        for(int j = i + 1; j < n; ++j) {
          // и соотв. инициализируем текущую подстроку (i, j) как не палиндром, т. е. false
          dp[i][j] = false;
          // далее, если символы совпадают,
          // где - "заводской" фабричный метод для получения символов
          if(s.charAt(i) == s.charAt(j)) {
            // промежуточная проверка, не приведет ли их удаление к появлению палиндрома
            dp[i][j] = dp[i + 1][j - 1];
            // обновляем начальную позицию и максимальную длину, если будет найден палиндром большего размера
            if(dp[i][j] && maxLentgh < j - i + 1) {
              maxLentgh = j - i + 1;
              startIdx = i;
            }
          }
        }
      }
      // по итогу извлекаем из строки самую длинную палиндромную подстроку,
      // где substring() - "заводской" фабричный метод, кот. возвращает новую строку, которая является подстрокой данной строки
      return s.substring(startIdx, startIdx + maxLentgh);
    }
  }
}
/*
Временная сложность предоставленного кода равна, так как он включает в себя два вложенных цикла, которые оба перебираются по длине строки.
В частности, внешний цикл отсчитывает от до, а внутренний цикл отсчитывает от до,
что приводит к квадратичному числу шагов с точки зрения длины входной строки .O(n^2)nn-20i+1ns
 */
