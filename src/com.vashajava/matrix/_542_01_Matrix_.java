package com.vashajava.matrix;

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;

/**
 * Класс _542_01_Matrix_ - 01 Матрица.
 *
 * @author Anton Shatkovskiy
 * @created 22.08.2024 г.
 */

/*
Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.

The distance between two adjacent cells is 1.

Example 1:

Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
Example 2:

Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 104
1 <= m * n <= 104
mat[i][j] is either 0 or 1.
There is at least one 0 in mat.

ПЕРЕВОД: 542. 01 Матрица.
Учитывая двоичную матрицу mxn mat, верните расстояние, равное ближайшему 0, для каждой ячейки.

Расстояние между двумя соседними ячейками равно 1.

Пример 1:

Входные данные: mat = [[0,0,0],[0,1,0],[0,0,0]]
Вывод: [[0,0,0],[0,1,0],[0,0,0]]

дургой вариант?=:
mat = [
  [0, 0, 1],
  [1, 1, 1],
  [1, 1, 0]
]

Пример 2:

Ввод: mat = [[0,0,0],[0,1,0],[1,1,1]]
Вывод: [[0,0,0],[0,1,0],[1,2,1]]

Ограничения:

m == длина матраса
n == math[i].длина
1 <= m, n <= 104
1 <= m * n <=
104 math[i][j] равно либо 0, либо 1.
В math есть как минимум один 0.
 */
public class _542_01_Matrix_ {

  public static void main(String[] args) {

    int[][] mat =  {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};

    Solution542 solution542 = new Solution542();
    int[][] updateMatrix = solution542.updateMatrix(mat);
    // вывод на печать - как требуется по условию,
    // где Arrays.deepToString() - библиотечный метод, предназначен только для преобразования многомерных массивов в строки
    System.out.println(Arrays.deepToString(updateMatrix));

  }

  // используется алгоритм поиска в ширину (BFS)
  static class Solution542 {
    public int[][] updateMatrix(int[][] mat) {

      // 1. Создание и инициализация вспомогательной матрицы, ее размеры равны размерам входной матрицы mat
      // получаем размеры матрицы - строки и колонки - стандартный библиотечный метод
      int rows = mat.length;
      int cols = mat[0].length;

      //  и создаем новую матрицу для хранения ответа с теми же размерами
      int[][] distanceMatrix = new int[rows][cols];

      // теперь инициализируем матрицу расстояний значением (флажком) -1, исп цикл упрощенный for, чтобы пометить ее как не обработанную
      for(int[] row : distanceMatrix) {
        // где Arrays.fill() — это метод в классе Arrays, который заполняет весь массив одним и тем же значением
        Arrays.fill(row, -1);
      }

      // 2. Создание и инициализация очереди, для хранения ячеек, расстояния между которыми необходимро вычислить
      // создаем очередь для выполнения BFS
      Deque<int[]> queue = new ArrayDeque<>();

      // перебираем каждую ячейку матрицы с пом. цикла
      for(int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
          // если текущая ячейка имеет значение 0, отмечаем ее в матрице расстояний и добавляем в очередь
          if (mat[i][j] == 0) {
            // где Метод queue.offer() — это метод интерфейса Queue, который вставляет указанный элемент в эту очередь,
            // если это возможно сделать немедленно без нарушения ограничений ёмкости.
            queue.offer(new int[] {i, j});
            distanceMatrix[i][j] = 0;
          }
        }
      }

      // 3. Реализация BFS
      // создаем новый массив, позволяющий выполнять итерацию по 4 соседним ячейкам (вверх, вправо, вниз, влево - обозночаются числовыми значениями)
      int[] directories = {-1, 0, 1, 0, -1};

      // теперь выполняем BFS в очереди до тех пор, пока она не опустеет - исп. цикл while,
      // исп. стандартный метод для проверки пустоты
      while (!queue.isEmpty()) {
        // опрашиваем элементы из очереди
        // где poll в интерфейсе Queue в Java возвращает с удалением элемент из начала очереди,
        // если очередь пуста, метод возвращает значение null
        // с созданием нового массива
        int[] position = queue.poll();
        // счетчики
        int currentRow = position[0];
        int currentCol = position[1];
        //  и далее с исп. цикла for выполняем итерацию по четырем возможным соседям текущей ячейки,
        //  т. е. счетчик для строк и столбцов + вверх, вправо, вниз, влево
        for(int k = 0; k < 4; ++k) {
          int newRow = currentRow + directories[k];
          int newCol = currentCol + directories[k + 1];

          // проверяем, находится ли новая ячейка в пределах допустимых границ и не была ли она еще посещена (т. е. признак -1),
          // с пом. цикла if задаем условие
          if(newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && distanceMatrix[newRow][newCol] == -1) {
            // то обновляемс матрицу расстояний, указав расстояние от ближайшего значения 0
            distanceMatrix[newRow][newCol] = distanceMatrix[currentRow][currentCol] + 1;
            // и далее добавляем новую ячейку в очередь, чтобы продолжить реализацию BFS
            // где Метод queue.offer() — это метод интерфейса Queue, который вставляет указанный элемент в эту очередь,
            // если это возможно сделать немедленно без нарушения ограничений ёмкости.
            queue.offer(new int[] {newRow, newCol});
          }
        }
      }
      // и последнее - возвращаем обновленную матрицу расстояний
      return distanceMatrix;
    }
  }
}

/*
Поскольку количество операций для каждого элемента постоянно, общая временная сложность этого кода составляет O(m * n).
 */
