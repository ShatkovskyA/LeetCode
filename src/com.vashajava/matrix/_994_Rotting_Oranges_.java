package com.vashajava.matrix;

import java.util.Deque;
import java.util.LinkedList;

/**
 * Класс _994_Rotting_Oranges_ - вращающиеся апельсины.
 *
 * @author Anton Shatkovskiy
 * @created 26.09.2024 г.
 */

/*
You are given an m x n grid where each cell can have one of three values:

0 representing an empty cell,
1 representing a fresh orange, or
2 representing a rotten orange.
Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.

Example 1:

Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
Example 2:

Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
Example 3:

Input: grid = [[0,2]]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 10
grid[i][j] is 0, 1, or 2.

ПЕРЕВОД: 994. Вращающиеся апельсины.
Вам предоставляется сетка mxn, в которой каждая ячейка может иметь одно из трех значений:

0 - пустая ячейка,
1 - свежий апельсин или
2 - гнилой апельсин.
Каждую минуту любой свежий апельсин, расположенный в 4-х направлениях рядом с гнилым апельсином, становится гнилым.

Возвращает минимальное количество минут, которое должно пройти до тех пор, пока ни в одной ячейке не останется свежего апельсина.
Если это невозможно, верните значение -1.

Пример 1:

Входные данные: сетка = [[2,1,1],[1,1,0],[0,1,1]]
Выходные данные: 4
Пример 2:

Входные данные: сетка = [[2,1,1],[0,1,1],[1,0,1]]
Выходные данные: -1
Пояснение: Апельсин в левом нижнем углу (строка 2, столбец 0) никогда не бывает гнилым, потому что гниение происходит только в 4 направлениях.
Пример 3:

Входные данные: grid = [[0,2]]
Выходные данные: 0
Пояснение: Поскольку на 0-й минуте свежих апельсинов уже нет, ответом будет просто 0.

Ограничения:

m == сетка.длина
n == сетка[i].длина
1 <= m, n <= 10
сетка[i][j] равна 0, 1 или 2.
 */

// используем расширенный поиск (BFS) в ширину, который хорошо подходит для задач, связанных с проходящими уровнями или минутами, как в данном случае.
// рассматриваем каждую минуту как уровень в прохождении BFS.
public class _994_Rotting_Oranges_ {

  public static void main(String[] args) {

    int[][] grid = {{2, 1, 1}, {1, 1, 0}, {0, 1, 1}};

    Solution994 solution994 = new Solution994();
    int orangesRotting = solution994.orangesRotting(grid);
    System.out.println(orangesRotting);

  }

  static class Solution994 {
    public int orangesRotting(int[][] grid) {
      // начинаем с инициализации базовых переменных
      // определяем начальную сетку матрицу и ее размеры
      // вводим переменную для количества строк в матрице
      int rows = grid.length;
      // вводим переменную для количества колонок в матрице
      int cols = grid[0].length;
      // вводим счетчик для свежих апельсинов
      int freshOranges = 0;
      // создаем очередь для позиции с гнилыми апельсинами
      Deque<int[]> queue = new LinkedList<>();

      // предварительно обрабатываем сетку, помещаем в очередь все гнилые апельсины и подсчитываем количество свежих
      for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
          // так,если апельсин подгнил, где "2" - это признак гнили (мы сами этот признак установили)
          if(grid[i][j] == 2) {
            // то гнилой апельсин помещаем в очередь, с помощью "заводсокого" стандартного библиотечного метода offer()
            queue.offer(new int[] {i, j});
            // но если апельсин свежий, где "1" - это признак свежести (мы сами этот признак установили)
          } else if(grid[i][j] == 1) {
            // тто счетчик для свежик апельсинов - увеличивается
            freshOranges++;
          }
        }
      }
      // теперь вводим b bybwbfkbpbhetv 0 счетчик времени процесса гниения
      int minutesElapsed = 0;
      // тут создаем и инициализируем вспомогательный массив для соседних ячеек: вправо, вниз, влево, вверх
      int[] directions = {-1, 0, 1, 0, -1};

      // это как раз цикл while для выполнения BFS с изначально гнилых апельсинов
      // итак, пока очередь не пуста и количество свежих апельсинов больше нуля
      while (!queue.isEmpty() && freshOranges > 0) {
        // величиваем время, так как каждый уровень BFS составляет 1 минуту
        minutesElapsed++;
        // далее перебираем гнилые апельсины в текущий момент времени - т. е. берем опять очередь
        for(int i = queue.size(); i > 0; --i) {
          int[] position = queue.poll();
          // где poll() - возвращает и удаляет элемент во внешней части контейнера.
          // удаляет элемент в контейнере, не генерирует исключение, когда очередь пуста, вместо этого он возвращает значение null
          // и далее проверяем все соседние ячейки, двигаемся последовательно - позиция + движение
          for(int j = 0; j < 4; ++j) {
            // координатв по x
            int x = position[0] + directions[j];
            // координатв по y
            int y = position[1] + directions[j + 1];
            // и опять вводим условие, если соседняя ячейка находится в пределах допустимых границ и содержит свежий апельсин
            if(x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == 1) {
              // то тут находится подгнивший свежий апельсин
              grid[x][y] = 2;
              // следовательно на счетчике уменьшанем количество свежих апельсинов
              freshOranges--;
              // ставим в очередь в позицию новый гнилой rotten orange
              queue.offer(new int[] {x, y});
            }
          }
        }
      }
      // и, посредством тернарного оператора, если еще остались свежие апельсины, верните значение -1, в противном случае верните прошедшее время
      return freshOranges > 0 ? -1 : minutesElapsed;
    }
  }
}

/*
Временная сложность кода составляет O(M * N), где M - количество строк,
а N - количество столбцов в сетке. Это потому, что в худшем случае нам,
возможно, придется просматривать каждую ячейку сетки. Цикл while выполняется до тех пор, пока все гнилые апельсины не будут обработаны.
В худшем случае обработка одного гнилого апельсина может затронуть 4 соседние ячейки,
но каждая ячейка ставится в очередь и удаляется из нее только один раз. Это дает нам наихудший сценарий обработки M * N ячеек.
*/
