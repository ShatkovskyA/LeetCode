package com.vashajava.matrix;

import jdk.swing.interop.SwingInterOpUtils;

/**
 * Класс _200_Number_of_slands_ количество островов.
 *
 * @author Anton Shatkovskiy
 * @created 25.09.2024 г.
 */

/*
Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.
You may assume all four edges of the grid are all surrounded by water.

Example 1:

Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
Example 2:

Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 300
grid[i][j] is '0' or '1'.

ПЕРЕВОД: 200. Количество островов.
Учитывая двоичную двухмерную сетку mxn, которая представляет собой карту из "1" (суша) и "0" (вода), возвращает количество островов.

Остров окружен водой и образуется путем соединения соседних земель по горизонтали или вертикали.
Вы можете предположить, что все четыре края сетки окружены водой.

Пример 1:

Входные данные: сетка = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Выходные данные: 1
Пример 2:

Входные данные: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Выход: 3

Ограничения:

m == сетка.длина
n == сетка[i].длина
1 <= m, n <= 300
сетка[i][j] равна "0" или "1".
 */

  // используем поиск в глубину (DFS) в качестве основного алгоритма для решения задачи нахождения количества островов в сетке
public class _200_Number_of_slands_ {

  public static void main(String[] args) {

    char[][] grid = {{'1', '1', '1', '1', '0'},
    {'1', '1', '0', '1', '0'},
      {'1', '1', '0', '0', '0'},
        {'0', '0', '0', '0', '0'}};

    Solution200 solution200 = new Solution200();
    int numIslands = solution200.numIslands(grid);
    System.out.println(numIslands);

  }
  static class Solution200 {
    // определяем матрицу(сетку) и ее размеры
    private char[][] grid;
    // тут вводим переменную для колонки
    private int numCols;
    // тут вводим переменную для строки
    private int numRows;

    // сам метод подсчета количества островов в заданной матрице
    public int numIslands(char[][] grid) {
      // определяем размеры двумерной матрицы
      // количество строк в матрице
      numRows = grid.length;
      // а тут количество колонок в матрице
      numCols = grid[0].length;
      // где объект - здесь, определенный изначально
      this.grid = grid;
      // вводим счетчик инициализации(нициализируем нулем - 0) количество островов
      int numIslands = 0;
      // теперь, пробегаясь циклом, выполняем итерацию по каждой ячейке сетки
      for (int i = 0; i < numRows; ++i) {
         for (int j = 0; j < numCols; ++j) {
           // условие, если ячейка содержит "1", то она является частью островка
           if(grid[i][j] == '1') {
             // т. е. тут используем DFS, чтобы отметить весь остров как посещенный,
             // - вызываем новый рекурсивный метод
             depthFirstSearch(i, j);
             // с помощью счетчика отмечаем / увечличиваем количество островов
             ++numIslands;
           }
        }
     }
      return numIslands;
    }

    // это как раз вспомогательный рекурсивный метод для выполнения DFS и для пометки всех ячеек острова как посещенных
    private void depthFirstSearch(int row, int col) {
      // отмечаем начало отсчета, т. е. текущую ячейку как посещенную, установив для нее значение "0"
      grid[row][col] = '0';
      // тут создаем и инициализируем вспомогательный массив для облегчения поиска смежных направлений (вверх, вправо, вниз, влево)
      int[] directions = {-1, 0, 1, 0, -1};

      // и, исследуем все 4 смежных направления путем пробегания циклом
      for (int k = 0; k < 4; ++k) {
        int newRows = row + directions[k];
        int newCols = col + directions[k + 1];
        // проверка границ(что выходит за границы матрицы) и то, является ли соседняя ячейка частью острова
        if(newRows >= 0 && newRows < numRows && newCols >= 0 && newCols < numCols && grid[newRows][newCols] == '1') {
          // и продолжаем рекурсивно поиск по DFS для соседней ячейки
          depthFirstSearch(newRows, newCols);

        }
      }
    }
  }
}

/*
Временная сложность кода равна O(m * n), где m - количество строк в сетке, а n - количество столбцов.
Это связано с тем, что алгоритм должен посетить каждую ячейку во всей сетке один раз, чтобы убедиться, что все части островов подсчитаны и отмечены.
Поиск DFS вызывается для каждой ячейки суши ('1'), которая еще не была посещена, и он обходит все соседние ячейки суши.
Хотя внешний цикл выполняется для m * n итераций, DFS посещает каждую ячейку один раз, гарантируя, что общая временная сложность остается линейной относительно общего количества ячеек.
 */
